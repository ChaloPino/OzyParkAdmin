using System.Text;

namespace OzyParkAdmin.UnionType.Generator;
internal static class Resources
{
    internal const string AttributeName = "TypeUnionAttribute";
    internal const string AttributeNameSpace = "TypeUnions";
    internal const string ReplaceParameterAttributeName = "ReplaceParameterAttribute";
    internal const string FunctionClassName = "Functions";
    internal const string TypeUnionName = "TypeUnion";

    internal static readonly string FunctionText = $$"""
// <auto-generated />
using System.Collections;
using System.Text;

#pragma warning disable 1591
#nullable enable

namespace {{AttributeNameSpace}};
internal static class {{FunctionClassName}}
{
    internal static string FormatValue<T>(T value) => $"{typeof(T)}.FullName: {FormatInternal(value)}";
    private static string? FormatInternal<T>(T value) => value is IEnumerable enumerable ? FormatEnumerable(enumerable) : FormatObject(value);
    private static string? FormatObject<T>(T value) => value?.ToString();
    private static string? FormatEnumerable(IEnumerable enumerable)
    {
        StringBuilder builder = new StringBuilder();
        IEnumerator enumerator = enumerable.GetEnumerator();
        while (enumerator.MoveNext())
        {
            if (builder.Length > 0)
            {
                builder.Append(',').Append(' ');
            }
            builder.Append(FormatInternal(enumerator.Current) ?? "null");                
        }
        return builder.ToString();
    }

}

""";

    internal static readonly string ReplaceParameterAttributeText = $$"""
// <auto-generated />
using System;

#pragma warning disable 1591
#nullable enable

namespace {{AttributeNameSpace}};
/// <summary>
/// Attribute used to replace some attribute type of a discriminated union class with another type and name.
/// </summary>
/// <remarks>
/// <para>
/// This attribute can be used multiple times in the same discriminated union class, but it cannot be used more times than the number of attribute types the class has.
/// </para>
/// <para>
/// The discriminated union class must be a generic type.
/// </para>
/// <para>
/// The <see cref="MemberName" /> must exists in the discriminated union class as an attribute type.
/// </para>
/// /// <para>
/// The <see cref="ForType" /> must be an open generic type with only one argument type.
/// </para>
/// </remarks>
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false, AllowMultiple = true)]
internal sealed class {{ReplaceParameterAttributeName}} : Attribute
{
    /// <summary>
    /// Creates a new instance of <see cref="{{ReplaceParameterAttributeName}}" />.
    /// </summary>
    /// <param name="memberName">
    /// The name of one of the members of the discriminated union class to be replaced. This member must be one of the argument types of the class.
    /// </param>
    public {{ReplaceParameterAttributeName}}(string memberName)
    {
        MemberName = memberName;
    }

    /// <summary>
    /// Gets the name of one of the members of the discriminated union class to be replaced.
    /// </summary>
    public string MemberName { get; }
        
    /// <summary>
    /// Gets or sets the type you want to replace the discriminated union class member with.
    /// It can be optional, and if it is not set, then the type remains with the member's original type.
    /// </summary>
    public Type? ForType { get; set; }

    /// <summary>
    /// Gets or sets The name you want to replace the class member with.
    /// It can be optional, and if it is not set, then the name remains with the member's original name.
    /// </summary>
    public string? ForName { get; set; }
}

""";

    internal static string GenerateAttribute(int count)
    {
        StringBuilder builder = new($$"""
            // <auto-generated />
            #pragma warning disable 1591

            using System;

            namespace {{AttributeNameSpace}}
            {
                [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct, Inherited = false, AllowMultiple = false)]
                internal sealed class {{AttributeName}}<{{GenerateAttributeConstructorTypeArguments(count)}}> : Attribute
                {
                    public {{AttributeName}}()
                    {
                    }

            """);
        for (int i = 0; i < count; i++)
        {
            builder.Append($@"
        public string Name{i} {{ get; set; }}");
        }
        builder.Append(@"
    }
}
");
        return builder.ToString();
    }

    private static string GenerateAttributeConstructorTypeArguments(int count) =>
        string.Join(", ", Enumerable.Range(0, count).Select(x => $"T{x}"));
}
